---
title: "Rmaincode"
output: html_document
date: "2023-12-18"
---

```{r}

#Library
library(dplyr)
rm(list = ls())
cat("\014")  # Clears the console



library(dplyr)
library(ggplot2)
library(mediation)



```


```{r}
#Read the data

ECfinal<- read.csv("C:/Users/sara ghasem pour/GitLab/Path2/Thesis/DataCleaning/ECfinal.csv")

```

SNAP
```{r}
# Create a new binary column 'SNAP_Selected' based on the presence of "SNAP" in 'CNP4'
ECfinal$SNAP <- ifelse(grepl("SNAP", ECfinal$CNP4, fixed = TRUE), 1, 0)


```


Picky eating- Parent control- Parent emotional

```{r}
# Define the mapping from text responses to numeric values
EClist <- c("Always" = 5, "Often" = 4, "Sometimes" =3 , "Rarely" = 2, "Never" = 1 )

# List the question columns for each category based on the names you provided
control_questions <- c("PFSQ5", "PFSQ17", "PFSQ18", "PFSQ20", "PFSQ24", "PFSQ26")
emotional_questions <- c("PFSQ25", "PFSQ21", "PFSQ22", "PFSQ15", "PFSQ13", "PFSQ2")
picky_questions <- c("CEBQ32", "CEBQ24", "CEBQ16", "CEBQ10", "CEBQ7")

# Convert text responses to numeric values and calculate mean scores for control, emotional eating, and picky eating
ECfinal <- ECfinal %>%
  mutate(
    across(all_of(control_questions), ~ as.numeric(EClist[.x]), .names = "numeric_{.col}"),
    across(all_of(emotional_questions), ~ as.numeric(EClist[.x]), .names = "numeric_{.col}"),
    across(all_of(picky_questions), ~ as.numeric(EClist[.x]), .names = "numeric_{.col}")
  ) %>%
  rowwise() %>%
  mutate(
    Control_Score = mean(c_across(starts_with("numeric_PFSQ")), na.rm = TRUE),
    Emotional_Score = mean(c_across(starts_with("numeric_PFSQ")), na.rm = TRUE),
    Picky_Score = mean(c_across(starts_with("numeric_CEBQ")), na.rm = TRUE)
  ) %>%
  ungroup()


```

```{r}
# test normality for main variables
variables_to_test <- c("Picky_Score", "Control_Score", "Emotional_Score")

# Apply the Shapiro-Wilk test to each variable
normality_tests <- lapply(ECfinal[variables_to_test], shapiro.test)

# Print the results
print(normality_tests)
#I tried log and cox box ,inverse to normality for both of them date remain nonnormal

??????????????????


```



Household
```{r}

household <- ECfinal$household

```



RaceEthnicity
```{r}
# Create a data frame with the race data
race_data <- data.frame(
  race_category = c("White", "Vietnamese", "Other Asian", "Native Hawaiian", 
                    "Japanese", "Chinese", "Black or African American", 
                    "Asian Indian", "Another race", 
                    "American Indian or Alaska Native", "Indonesian", "Bengali", "Asian"),
  value = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3),
  detailed_description = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, "Indonesian", "Bengali", "Asian")
)
# Convert race_category to a factor with levels ordered by the value column
race_data$race_numeric <- as.numeric(factor(race_data$race_category, 
                                            levels = unique(race_data$race_category[order(race_data$value)])))


```


ParentEducation
```{r}
# Define the mapping from education levels to numeric values
education_map <- c("Some high school" = 1, 
                   "High school degree or GED" = 2, 
                   "Some college or associates degree" = 3, 
                   "4 years college degree" = 4, 
                   "Advanced degree" = 5)

# Convert text responses to numeric values for Education
ECfinal <- ECfinal %>%
  mutate(Education = education_map[ed])

```

HouseholdIncome
```{r}
income_map <- c("Less than $20,000" = 1, 
                "$20,000 - $39,999" = 2, 
                "$40,000 - $49,999" = 3, 
                "$50,000 - $74,999" = 4, 
                "$75,000 - $99,999" = 5, 
                "More than $100,000" = 6)
#Convert text responses to numeric values and calculate mean scores for Income
ECfinal <- ECfinal %>%
  mutate(Income = income_map[income])

```

Gender
```{r}

# Create a new binary column 'Sex_Male' based on the value of 'sex'
ECfinal$Gender <- ifelse(ECfinal$gender == 'Female', 1, 0)




```

Child_sex
```{r}


# Create a new binary column 'Sex_Male' based on the value of 'sex'
ECfinal$Sex <- ifelse(ECfinal$sex == 'Male', 1, 0)





```

Mediation


```{r}
# Load necessary library for mediation analysis
library(mediation)
library(car)


# SNAP is the mediator 

# Mediation analysis with interactions
mediator_model <- glm(SNAP ~ Control_Score + Emotional_Score + 
                        Control_Score + Sex + 
                        Income + Education + Gender + household,
                      family = binomial, data = ECfinal)


#Check Multicollinearity 

numeric_cols <- c("Control_Score", "Emotional_Score", "Sex", "Income", "Education", "Gender", "household")

# Convert columns to numeric 
ECfinal[numeric_cols] <- lapply(ECfinal[numeric_cols], function(x) as.numeric(as.character(x)))
#create correlation matrixs to assess multi clearity
cor_matrix <- cor(ECfinal[numeric_cols], use = "pairwise.complete.obs")
print(cor_matrix)






# Adjusting the outcome model to include covariates
outcome_model <- lm(Picky_Score ~ Control_Score + Emotional_Score + SNAP + 
                      Control_Score + sex + Income + Education + gender + household
                    ,data = ECfinal)
#chek multiclirity
# Correlation Matrix
cor_matrix <- cor(ECfinal[c("Control_Score", "Emotional_Score", "SNAP", "Sex", "Income", "Education", "Gender", "household")], use = "complete.obs")
print(cor_matrix)








# Perform the mediation analysis
med_fit <- mediate(mediator_model, outcome_model, treat = c("Control_Score"), mediator = "SNAP", boot = TRUE, sims = 500)

# View the summary of mediation analysis
summary(med_fit)

```






 relationship between parental feeding style, child picky eating and BMI

```{r}
#library
install.packages("ggplot2")
library("ggplot2")
install.packages("childsds")
library("childsds")
install.packages("anthro")
library("anthro")


 #read data
cmeasure<- read.csv("C:/Users/sara ghasem pour/GitLab/Path2/Thesis/DataCleaning/cmeasure.csv")


#merged ECfinal with measurment data based on RandomID
Data <- merge(cmeasure, ECfinal, by = "RandomID")


```



```{r}
#BMI Percentile

Data$BMIpercentile <- sds(
  value = Data$BMI,
  age = Data$Age,
  sex = Data$sex,
  male = "Male",
  female = "Female",
  ref = cdc.ref,
  item = "bmi",
  type = "perc"
)*100

#Test normality on continuous variables
tBMI <- shapiro.test(Data$BMIpercentile)
print(tBMI)

#Normalized:again I used log , coxbox and inverse but still dosent have normal distribution
??????????


# to put BMI percentile between 0_1

Data$BMIpercentile <- Data$BMIpercentile / 100




```


GLM

```{r}


glm<- glm(BMIpercentile ~ Picky_Score + Emotional_Score + 
                           Picky_Score * Emotional_Score+ SNAP + 
                      Control_Score + Sex + Income + Education + Gender + household,
                         family = quasibinomial(link = "logit"), data = Data)



#  Check for Multicollinearity
variables_for_cor <- c("Picky_Score", "Emotional_Score", "SNAP", "Control_Score", "Sex", "Income", "Education", "Gender", "household")
#ensure numeric type
Data[variables_for_cor] <- lapply(Data[variables_for_cor], function(x) as.numeric(as.character(x)))
# imputation missing data
Data_imputed <- Data
for (col in variables_for_cor) {
  Data_imputed[[col]] <- ifelse(is.na(Data_imputed[[col]]), mean(Data_imputed[[col]], na.rm = TRUE), Data_imputed[[col]])
}

# Calculate correlation matrix
# Using the dataset with handled missing values (choose Data_complete or Data_imputed)
cor_matrix <- cor(Data_imputed[variables_for_cor], use = "pairwise.complete.obs")
print(cor_matrix)








```





